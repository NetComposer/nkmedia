%% -------------------------------------------------------------------
%%
%% Copyright (c) 2016 Carlos Gonzalez Florido.  All Rights Reserved.
%%
%% This file is provided to you under the Apache License,
%% Version 2.0 (the "License"); you may not use this file
%% except in compliance with the License.  You may obtain
%% a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing,
%% software distributed under the License is distributed on an
%% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
%% KIND, either express or implied.  See the License for the
%% specific language governing permissions and limitations
%% under the License.
%%
%% -------------------------------------------------------------------

%% @doc Session Management
-module(nkmedia_fs_session).
-author('Carlos Gonzalez <carlosj.gf@gmail.com>').
-behaviour(gen_server).

-export([init/2, terminate/2, offer_op/4]).

-define(LLOG(Type, Txt, Args, State),
    lager:Type("NkMEDIA FS Session ~s (~p) "++Txt, 
               [State#state.id, State#state.status | Args])).

-include("nkmedia.hrl").

%% ===================================================================
%% Types
%% ===================================================================

-type id() :: nkmedia_session:id().
-type session() :: nkmedia_session:session().
-type continue() :: nkservice_callbacks:continue().


-type config() :: 
    nkmedia_session:config() |
    #{
}.

-type offer_op() ::
    nkmedia_session:offer_op() |
    pbx.


-type answer_op() ::
    nkmedia_session:answer_op() |
    pbx.


-type update() ::
    nkmedia_session:update() |
    term().                 


-type op_opts() ::  
    nkmedia_session:op_opts() |
    #{
    }.




%% ===================================================================
%% Callbacks
%% ===================================================================


-spec init(id(), session()) ->
    {ok, session()}.

init(Id, Session) ->
    State = #state{id=Id, srv_id=SrvId},
    {ok, Session#{nkmedia_fs=>State}}.


%% @doc Called when the session stops
-spec terminate(Reason::term(), session()) ->
    {ok, session()}.

terminate(_Reason, Session) ->
    {ok, Session}.


%% @private You must generte an offer() for this offer_op()
%% ReplyOpts will only we used for user notification
-spec offer_op(nkmedia:offer_op(), nkmedia:op_opts(), {pid(), term()}, session()) ->
    {ok, nkmedia:offer(), ReplyOpts::map(), session()} |
    {error, term(), session()} | continue().

offer_op(pbx, Opts, _From, #{nkmedia_fs:=State}=Session) ->
    case get_pbx_offer(Opts, State, Session) of
        {ok, Offer, Session2} ->
            {ok, {offer, Offer}, #{}, Session2};
        {error, Error} ->
            {error, Error, Session}
    end;

offer_op(_Op, _Opts, _From, _Session) ->
    continue.


%% @private
-spec answer_op(nkmedia:answer_op(), nkmedia:op_opts(), {pid(), term()}, session()) ->
    {ok, nkmedia:answer(), ReplyOpts::map(), session()} |
    {error, term(), session()} | continue().

answer_op(pbx, Opts, _From, #{nkmedia_fs:=State}=Session) ->
    #{offer:=Offer} = Session,
    case place_in_pbx(Offer, State, Session) of
        {ok, Answer, Session2} ->
            {ok, {answer, Answer}, #{}, Session2};
        {error, Error} ->
            {error, Error, Session}
    end;

answer_op(_Op, _Opts, _From, _Session) ->
    continue.









%% ===================================================================
%% Internal
%% ===================================================================


%% @private
place_in_pbx(_Offer, #state{dir=in}=State) ->
    {error, already_set};

place_in_pbx(_Offer, #state{dir=out}=State) ->
    {error, incompatible_direction};

place_in_pbx(Offer, #state{fs_id=undefined, dir=undefined}=State) ->
    case get_mediaserver(State) of
        {ok, #state{fs_id=Id}=State2} when Id /= undefined ->
            place_in_pbx(Offer, State2);
        {error, Error} ->
            {error, Error, State}
    end;

place_in_pbx(Offer, #state{id=SessId, fs_id=FsId}=State) ->
    case nkmedia_fs_verto:start_in(SessId, FsId, Offer) of
        {ok, SDP} ->
            wait_park(State),
            {ok, #{sdp=>SDP}, State#state{dir=in}};
        {error, Error} ->
            {error, Error, State}
    end.


%% @private
get_pbx_offer(_Opts, #state{dir=out}, _Session) ->
    {error, already_set};

get_pbx_offer(_Opts, #state{dir=in}, _Session) ->
    {error, incompatible_direction};

get_pbx_offer(Opts, #state{fs_id=undefined, dir=undefined}=State, Session) ->
    case get_mediaserver(State, Session) of
        {ok, Id, Session2} when Id /=undefined ->
            State2 =  State#state{fs_id=Id},
            get_pbx_offer(Opts, State2, update(State2, Session2));
        {error, Error} ->
            {error, {get_pbx_offer_error, Error}}
    end;

get_pbx_offer(Opts, #state{id=SessId, fs_id=FsId}=State, Session) ->
    Type = maps:get(sdp_type, Opts, webrtc),
    Mod = fs_mod(Type),
    case Mod:start_out(SessId, FsId, #{}) of
        {ok, SDP} ->
            State2 = State#state{dir=out},
            {ok, #{sdp=>SDP, sdp_type=>Type}, update(State2, Session)};
        {error, Error} ->
            {error, {backend_out_error, Error}, State}
    end.



%% @private
-spec get_mediaserver(#state{}, session()) ->
    {ok, session()} | {error, term()}.

get_mediaserver(#state{fs_id=undefined, srv_id=SrvId}=State, Session) ->
    case SrvId:nkmedia_fs_get_mediaserver(Session) of
        {ok, Id, Session2} ->
            State2 = State#state{fs_id=}
            Session3 = Session2#{mediaserver=>MS},
            {ok, State#state{ms=MS, session=Session3}};
        {error, Error} ->
            {error, Error}
    end;

get_mediaserver(State) ->
    {ok, State}.



%% @private
update(State, Session) ->
    Session#{nkmedia_fs:=State}.


%% @private
fs_mod(webrtc) ->nkmedia_fs_verto;
fs_mod(sip) -> nkmedia_fs_sip.


%% @private
wait_park(State) ->
    receive
        {'$gen_cast', {pbx_event, _, parked}} -> ok
    after 
        2000 -> 
            ?LLOG(warning, "parked not received", [], State)
    end.
