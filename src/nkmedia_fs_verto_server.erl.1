%% -------------------------------------------------------------------
%%
%% Copyright (c) 2016 Carlos Gonzalez Florido.  All Rights Reserved.
%%
%% This file is provided to you under the Apache License,
%% Version 2.0 (the "License"); you may not use this file
%% except in compliance with the License.  You may obtain
%% a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing,
%% software distributed under the License is distributed on an
%% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
%% KIND, either express or implied.  See the License for the
%% specific language governing permissions and limitations
%% under the License.
%%
%% -------------------------------------------------------------------

%% @doc Full verto server to use with verto clients
-module(nkmedia_fs_verto_server).
-author('Carlos Gonzalez <carlosj.gf@gmail.com>').

-export([invite/4, answer/2, hangup/1, hangup/2, get_user/1, get_all/0]).
-export([transports/1, default_port/1]).
-export([conn_init/1, conn_encode/2, conn_parse/3, conn_handle_call/4, 
         conn_handle_info/3, conn_stop/3]).

-define(LLOG(Type, Txt, Args, State),
    lager:Type("NkMEDIA verto server (~s, ~p) "++Txt, 
               [State#state.user, State#state.status | Args])).

-define(PRINT(Info, Msg), 
        nkmedia_fs_verto_util:print("NkMEDIA verto server "++Info, Msg),
        ok).


%% ===================================================================
%% Callbacks
%% ===================================================================


-callback nkmedia_verto_init(nkpacket:nkport(), State::map()) ->
    {ok, State::map()}.


-callback nkmedia_verto_login(VertoSessId::binary(), Login::binary(), Pass::binary(),
                              State::map()) ->
    {ok, State::map()} | {error, term(), State::map()}.


-callback nkmedia_verto_invite(CallId::binary(), Dialog::map(), SDP::binary(), 
                               State::map()) ->
    {ok, State::map()}.

-callback nkmedia_verto_answer(CallId::binary(), Dialog::map(), SDP::binary(), 
                               State::map()) ->
    {ok, State::map()}.

-callback nkmedia_verto_bye(CallId::binary(), State::map()) ->
    {ok, State::map()}.


-callback nkmedia_verto_dtmf(CallId::binary(), DTMF::binary(), State::map()) ->
    {ok, State::map()}.


-callback nkmedia_verto_terminate(Reason::term(), State::map()) ->
    {ok, State::map()}.



%% ===================================================================
%% Public
%% ===================================================================


invite(Pid, CallId, Dialog, SDP) ->
    nklib_util:call(Pid, {invite, CallId, Dialog, SDP}).

answer(Pid, SDP) ->
    nklib_util:call(Pid, {answer, SDP}).

hangup(Pid) ->
    hangup(Pid, 16).

hangup(Pid, Code) ->
    Pid ! {hangup, Code}.

get_user(Login) ->
    nklib_proc:values({?MODULE, login, nklib_util:to_binary(Login)}).


get_all() ->
    nklib_proc:values(?MODULE).



%% ===================================================================
%% Protocol callbacks
%% ===================================================================


-record(state, {
    remote :: binary(),
    callback :: atom(),
    session = <<>> :: binary(),
    user = <<"undefined">> :: binary(),
    current_id = 1 :: integer(),
    status :: init | registered | ringing | calling | in_call | hangup,
    call_id = <<>> :: binary(),
    bw_bytes :: integer(),
    bw_time :: integer(),
    timer :: reference(),
    substate :: map()
}).


%% @private
-spec transports(nklib:scheme()) ->
    [nkpacket:transport()].

transports(_) -> [wss, ws].

-spec default_port(nkpacket:transport()) ->
    inet:port_number() | invalid.

default_port(ws) -> 8081;
default_port(wss) -> 8082.


-spec conn_init(nkpacket:nkport()) ->
    {ok, #state{}}.

conn_init(NkPort) ->
    {ok, _Class, #{callback:=Callback}} = nkpacket:get_user(NkPort),
    {ok, Remote} = nkpacket:get_remote_bin(NkPort),
    case erlang:function_exported(Callback, nkmedia_verto_init, 2) of
        true ->
            {ok, SubState} = Callback:nkmedia_verto_init(NkPort, #{});
        false ->
            SubState = #{}
    end,
    State = #state{remote=Remote, callback=Callback, status=init, substate=SubState},
    nklib_proc:put(?MODULE, #{remote=>Remote}),
    ?LLOG(info, "new connection (~p)", [self()], State),
    {ok, State}.


%% @private
-spec conn_parse(term()|close, nkpacket:nkport(), #state{}) ->
    {ok, #state{}} | {stop, term(), #state{}}.

conn_parse(close, _NkPort, State) ->
    {ok, State};

% conn_parse({text, <<"#S", _/binary>>=Msg}, _NkPort, State) ->
%     #state{fs_session_pid=FsSession} = State,
%     case FsSession of
%         undefined ->
%             ?LLOG(warning, "received bw test without login", [], State),
%             {stop, normal, State};
%         Pid ->
%             nkmedia_fs_verto_client:send_bw_test(Pid, Msg),
%             {ok, State}
%     end;

%% Start of client bandwith test
conn_parse({text, <<"#SPU ", BytesBin/binary>>}, _NkPort, State) ->
    Bytes = nklib_util:to_integer(BytesBin),
    262144 = Bytes,
    Now = nklib_util:l_timestamp(),
    ?PRINT("client BW", io_lib:format("start test (SPU, ~p)", [Bytes])),
    State2 = State#state{bw_bytes=Bytes, bw_time=Now},
    {ok, State2};

%% Client sends bw data
conn_parse({text, <<"#SPB", _/binary>>=Msg}, _NkPort, State) ->
    Size = byte_size(Msg) - 4,
    #state{bw_bytes=Bytes} = State,
    {ok, State#state{bw_bytes=Bytes-Size}};

%% Client sends bw end
conn_parse({text, <<"#SPE">>}, NkPort, State) ->
    #state{bw_bytes=Bytes, bw_time=Time} = State,
    Now = nklib_util:l_timestamp(),
    case (Now - Time) div 1000 of
        0 -> 
            ?LLOG(warning, "client bw test error1", [], State),
            {ok, State};
        ClientDiff when Bytes==0 ->
            ?PRINT("BW", io_lib:format("client completed (~p msecs, ~p Kbps)", 
                                [ClientDiff, 262144*8 div ClientDiff])),
            %% We send start of server bw test
            Msg1 = <<"#SPU ", (nklib_util:to_binary(ClientDiff))/binary>>,
            case send(Msg1, NkPort) of
                ok ->
                    case send_bw_test(NkPort) of
                        {ok, ServerDiff} ->
                            ?PRINT("BW", 
                                    io_lib:format("server completed (~p msecs, ~p Kpbs)",
                                                  [ServerDiff, 262144*8 div ServerDiff])),
                            %% We send end of server bw test
                            Msg2 = <<"#SPD ", (nklib_util:to_binary(ServerDiff))/binary>>,
                            send(Msg2, NkPort, State);
                        {error, Error} ->
                           ?LLOG(warning, "server bw test error2: ~p", [Error], State),
                           {stop, normal, State}
                    end;
                {error, _} ->
                    {stop, normal, State}
            end;
        _ ->
            ?LLOG(warning, "client bw test error3", [], State),
            {stop, normal, State}
    end;

conn_parse({text, Data}, NkPort, State) ->
    Msg = case nklib_json:decode(Data) of
        error ->
            ?LLOG(warning, "JSON decode error: ~p", [Data], State),
            error(json_decode);
        Json ->
            Json
    end,
    ?PRINT("recv", Msg),
    case nkmedia_fs_verto_util:parse_class(Msg) of
        {{req, Method}, _Id} ->
            process_client_req(Method, Msg, NkPort, State);
        {{resp, Resp}, _Id} ->
            process_client_resp(Resp, Msg, NkPort, State);
        unknown ->
            {ok, State}
    end.


-spec conn_encode(term(), nkpacket:nkport()) ->
    {ok, nkpacket:outcoming()} | continue | {error, term()}.

conn_encode(Msg, _NkPort) when is_map(Msg) ->
    Json = nklib_json:encode(Msg),
    {ok, {text, Json}};

conn_encode(Msg, _NkPort) when is_binary(Msg) ->
    {ok, {text, Msg}}.


-spec conn_handle_call(term(), {pid(), term()}, nkpacket:nkport(), #state{}) ->
    {ok, #state{}} | {stop, Reason::term(), #state{}}.

conn_handle_call({answer, SDP}, From, _NkPort, #state{status=calling}=State) ->
    gen_server:reply(From, ok),
    #state{call_id=CallId, current_id=Id} = State,
    Data = #{<<"callID">> => CallId, <<"sdp">> => SDP},
    Msg = nkmedia_fs_verto_util:make_req(Id, <<"verto.answer">>, Data),
    State2 = update_status(in_call, State#state{current_id=Id+1}),
    send(Msg, State2);

conn_handle_call({answer, _}, From, _NkPort, State) ->
    gen_server:reply(From, {error, invalid_status}),
    {ok, State};


%% Poner ringing hasta recibir el answer
conn_handle_call({invite, _CallId, _Dialog, SDP}, From, _NkPort, 
                 #state{status=registered}=State) ->
    gen_server:reply(From, ok),
    #state{call_id=CallId, current_id=Id} = State,
    Data = #{<<"callID">> => CallId, <<"sdp">> => SDP},
    Msg = nkmedia_fs_verto_util:make_req(Id, <<"verto.answer">>, Data),
    State2 = State#state{current_id=Id+1},
    send(Msg, State2);

conn_handle_call({invite, _, _, _}, From, _NkPort, State) ->
    gen_server:reply(From, {error, invalid_status}),
    {ok, State};
 
 conn_handle_call(Msg, _From, _NkPort, State) ->
    lager:warning("Module ~p received unexpected call: ~p", [?MODULE, Msg]),
    {ok, State}.


-spec conn_handle_info(term(), nkpacket:nkport(), #state{}) ->
    {ok, #state{}} | {stop, Reason::term(), #state{}}.

%% @doc In case we use the FS-based method
conn_handle_info({verto_bw_test, Data}, NkPort, State) ->
    send(Data, NkPort, State);

conn_handle_info({hangup, _Code}, _NkPort, State) ->
    %% TODO: Send proponer by
    {stop, normal, State};

% conn_handle_info({'DOWN', _, process, Pid, _}, _NkPort, #state{ch_pid=Pid}=State) ->
%     ?LLOG(notice, "remote channel stopped, hanging up", [], State),
%     {stop, normal, State};

conn_handle_info(Info, _NkPort, State) ->
    lager:warning("Module ~p received unexpected info: ~p", [?MODULE, Info]),
    {ok, State}.


%% @doc Called when the connection stops
-spec conn_stop(Reason::term(), nkpacket:nkport(), #state{}) ->
    ok.

conn_stop(Reason, _NkPort, State) ->
    handle(nkmedia_verto_terminate, [Reason], State).



%% ===================================================================
%% Requests
%% ===================================================================

%% @private
process_client_req(<<"login">>, Msg, NkPort, State) ->
    #{<<"params">> := Params} = Msg,
    case Params of
        #{
            <<"login">> := Login,
            <<"passwd">> := Passwd,
            <<"sessid">> := SessId
        } ->
            case handle(nkmedia_verto_login, [SessId, Login, Passwd], State) of
                {ok, State2} ->
                    ReplyParams = #{
                        <<"message">> => <<"logged in">>, 
                        <<"sessid">> => SessId
                    },
                    #state{remote=Remote} = State,
                    nklib_proc:put(?MODULE, Login),
                    nklib_proc:put({?MODULE, user, Login}, #{remote=>Remote}),
                    Reply = nkmedia_fs_verto_util:make_resp(ReplyParams, Msg),
                    State3 = State2#state{session=SessId, user=Login},
                    send(Reply, NkPort, update_status(registered, State3));
                {error, Error, State2} ->
                    ?LLOG(info, "login user error for ~s: ~p", [Login, Error], State2),
                    Reply = make_error(-32001, "Authentication Failure", Msg),
                    send(Reply, NkPort, State2)
            end;
        _ ->
            Reply = make_error(-32000, "Authentication Required", Msg),
            send(Reply, NkPort, State)
    end;

process_client_req(<<"verto.invite">>, Msg, NkPort, #state{status=registered}=State) ->
    #{<<"params">> := #{<<"dialogParams">> := Dialog, <<"sdp">> := SDP}} = Msg,
    #{<<"callID">> := CallId} = Dialog,
    {ok, State2} = handle(nkmedia_verto_invite, [CallId, Dialog, SDP], State),
    #state{session=SessionId} = State,
    Data = #{
        <<"callID">> => CallId,
        <<"message">> => <<"CALL CREATED">>,
        <<"sessid">> => SessionId
    },
    Resp = nkmedia_fs_verto_util:make_resp(Data, Msg),
    State3 = update_status(calling, State2#state{call_id=CallId}),
    send(Resp, NkPort, State3);

process_client_req(<<"verto.invite">>, Msg, NkPort, State) ->
    Resp = make_error(-40000, "Invalid Status", Msg),
    send(Resp, NkPort, State);

process_client_req(<<"verto.answer">>, Msg, NkPort, #state{status=ringing}=State) ->
    Resp = nkmedia_fs_verto_util:make_resp(#{}, Msg),
    State2 = update_status(in_call, State),
    send(Resp, NkPort, State2);

process_client_req(<<"verto.answer">>, Msg, NkPort, State) ->
    Resp = make_error(-40000, "Invalid Status", Msg),
    send(Resp, NkPort, State);

process_client_req(<<"verto.bye">>, Msg, NkPort, #state{status=Status}=State)
        when Status==calling; Status==in_call ->
    #state{call_id=CallId} = State,
    #{<<"params">> := #{<<"dialogParams">> := #{<<"callID">> := CallId}}} = Msg,
    {ok, State2} = handle(nkmedia_verto_bye, [CallId], State),
    #state{session=SessionId} = State,
    Data = #{
        <<"callID">> => CallId,
        <<"cause">> => <<"NORMAL_CLEARING">>,
        <<"causeCode">> => 16,
        <<"message">> => <<"CALL ENDED">>,
        <<"sessid">> => SessionId
    },
    Resp = nkmedia_fs_verto_util:make_resp(Data, Msg),
    State3 = update_status(registered, State2#state{call_id = <<>>}),
    send(Resp, NkPort, State3);

process_client_req(<<"verto.bye">>, Msg, NkPort, State) ->
    Resp = make_error(-40000, "Invalid Status", Msg),
    send(Resp, NkPort, State);

process_client_req(<<"verto.info">>, Msg, NkPort, #state{status=in_call}=State) ->
    #{<<"params">> := #{<<"dialogParams">> := Dialog, <<"dtmf">> := DTMF}} = Msg,
    #{<<"callID">> := CallId} = Dialog,
    {ok, State2} = handle(nkmedia_verto_dtmf, [CallId, DTMF], State),
    #state{session=SessionId} = State,
    Data = #{
        <<"message">> => <<"SENT">>,
        <<"sessid">> => SessionId
    },
    Resp = nkmedia_fs_verto_util:make_resp(Data, Msg),
    send(Resp, NkPort, State2);

process_client_req(<<"verto.info">>, Msg, NkPort, State) ->
    Resp = make_error(-40000, "Invalid Status", Msg),
    send(Resp, NkPort, State);

process_client_req(Method, Msg, _NkPort, State) ->
    ?LLOG(warning, "unexpected client request ~s: ~p", [Method, Msg], State),
    {ok, State}.


%% @private
process_client_resp({ok, <<"verto.answer">>}, _, _NkPort, State) ->
    {ok, State};

process_client_resp(Resp, Msg, _NkPort, State) ->
    ?LLOG(warning, "unexpected client response ~p: ~p", [Resp, Msg], State),
    {ok, State}.


%% ===================================================================
%% Util
%% ===================================================================


%% @private
send(Msg, NkPort, State) ->
    ?PRINT("send", Msg),
    case send(Msg, NkPort) of
        ok -> 
            {ok, State};
        error -> 
            ?LLOG(notice, "error sending reply:", [], State),
            {stop, normal, State}
    end.


send(Msg, NkPort) ->
    nkpacket_connection:send(NkPort, Msg).


%% @private
update_status(Status, #state{status=Status}=State) ->
    State;

update_status(NewStatus, #state{status=OldStatus, timer=Timer}=State) ->
    nklib_util:cancel_timer(Timer),
    Time = case NewStatus of
        registered -> 0
    end,
    Timer = case Time of
        0 -> undefined;
        _ -> elang:start_timer(1000*Time, self(), nkmedia_timeout)
    end,
    ?LLOG(info, "status ~p -> ~p", [OldStatus, NewStatus], State),
    State#state{timer=Timer}.


%% @private
make_error(Code, Txt, Msg) ->
    nkmedia_fs_verto_util:make_error(Code, Txt, Msg).


%% @private
handle(Fun, Args, State) ->
    case 
        nklib_gen_server:handle_any(Fun, Args, State, #state.callback, #state.substate)
    of
        nklib_not_exported -> {ok, State};
        Other -> Other
    end.



%%%% Bandwith test


%% @private
send_bw_test(NkPort) ->
    case send_bw_test(10, 0, NkPort) of
        {ok, Time} -> {ok, max(1, Time div 10)};
        {error, Error} -> {error, Error}
    end.


%% @private
send_bw_test(0, Acc, _NkPort) ->
    {ok, Acc};

send_bw_test(Iter, Acc, NkPort) ->
    Start = nklib_util:l_timestamp(),
    case nkpacket_connection_lib:raw_send(NkPort, fun bw_frames/0) of
        ok -> 
            Time = (nklib_util:l_timestamp() - Start) div 1000,
            % lager:warning("TIME: ~p", [Time]),
            send_bw_test(Iter-1, Acc+Time, NkPort);
        {error, Error} -> 
            {error, Error}
    end.


%% @private Send 256*1024 => 262144 bytes
bw_frames() ->
    [{text, bw_msg()} || _ <- lists:seq(1,256)].


%% @private. A 1024 value
bw_msg() ->
     <<"#SPB............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................">>.


